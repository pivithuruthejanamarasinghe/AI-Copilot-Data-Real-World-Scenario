prompt,completion
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job information is available in the source.txt file. However, there's an added complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, ensure that the solutions are printed and visually represented for thorough evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We need to create a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once this is resolved, ensure the solutions are thoroughly documented and visually presented for a comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []"
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)"
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_QUANTITY_CONSTRAINTS]",#
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_TARDINESS_CONSTRAINTS]",#
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"I'm seeking assistance in developing schedule for Shiny Printing Factory with makespan as the primary objective function. The job information is contained in the source.txt file. Once the problem has been successfully addressed, could you please arrange for the solutions to be printed and visually presented?[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_QUANTITY_CONSTRAINTS]",#
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_TARDINESS_CONSTRAINTS]",#
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our goal is to create a schedule for Shiny Factory to minimize the makespan. The job details can be found in source_machine_13.txt. An added complexity is that each job has a random release time. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. After solving the scheduling problem, we must print and visualize the solutions for comprehensive analysis.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_QUANTITY_CONSTRAINTS]",#
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_TARDINESS_CONSTRAINTS]",#
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our goal is to devise an optimal schedule for Shiny Factory with a focus on minimizing makespan. The job specifications are recorded in source_machine_13.txt. However, we encounter a significant challenge: each job is associated with a random release time. Additionally, we have imposed a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we must explore alternative machine options. Once we address this scheduling complexity, it is crucial to meticulously document and visually present the solutions to facilitate comprehensive analysis and evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"Our objective is to devise a schedule for Shiny Factory aimed at minimizing maximum tardiness. The job specifications, including quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. Tasks labeled as very small quantities will be managed by the Little Fang Machine, while those with small quantities will be handled by the 7-Head Machine. However, it's crucial to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times, adding complexity to the scheduling process. Upon successfully addressing this challenge, we must ensure that the solutions are meticulously documented and visually represented for comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We need to develop a schedule for Shiny Factory with the goal of minimizing makespan. The job specifications are in the source_machine_13.txt file, but there's a challenge: the jobs have random release times. Additionally, there's a constraint for the 7-Head Machine. if it experiences more than 2 units of waiting time, we should consider using another machine. Once the problem is solved, please print and visually present the solutions for thorough analysis.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented. After successfully addressing this challenge, need to ensure that the solutions are thoroughly documented and visually represented.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our objective is to devise an optimized schedule for Shiny Factory, aiming to minimize maximum tardiness. The job specifications, categorized by quantity labels (very small, small, and large), are detailed in the source-quantity.txt file. We've designated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3, adding to the scheduling complexity. Moreover, the stochastic nature of job release times further complicates the optimization process. Once we successfully address these challenges, it's imperative to ensure comprehensive documentation and visual representation of the solutions for thorough evaluation and future[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We're working on developing a schedule for Shiny Factory with the main goal of minimizing maximum tardiness. The job details are in source.txt. The challenge is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. Once we've resolved this, please ensure the solutions are documented and visually presented for a comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
