prompt,completion
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m"
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We're looking to establish a schedule for Shiny Factory with the primary objective of minimizing makespan. The job specifications are documented in source_machine_13.txt. However, there's a notable challenge: the jobs come with random release times. Adding to the complexity, there's a specific condition regarding the 7-Head Machine: if it exceeds a waiting time of 2 units, we need to explore utilizing another machine. Once the problem is resolved, it's crucial to document and visualize the solutions for comprehensive analysis.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our task is to create a schedule for Shiny Factory, aiming to minimize maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine handles very small jobs, and the 7-Head Machine deals with small ones. But if a job's too big for a machine, it won't handle it. We've got a special rule for the 7-Head Machine—if its waiting time goes over three units, we consider using another machine. Due dates are calculated by multiplying each job's total processing time by 1.3. Plus, jobs have random release times. Once we sort this out, we'll make sure everything's written down and visually shown.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5"
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m"
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_QUANTITY_CONSTRAINTS]",#
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_TARDINESS_CONSTRAINTS]",#
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We need to come up with a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source.txt file, but there's a catch: the jobs have random release times. Can you include that in your optimization? After you solve it, please print out the solutions and show them visually for us to review. Thanks![DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_TARDINESS_CONSTRAINTS]",#
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We need a schedule for Shiny Factory to keep the makespan as short as possible. The job specs are in the source-quantity.txt file, with each job marked as very small, small, or large. The Little Fang Machine handles very small quantities, and the 7-Head Machine handles small quantities. If a job is too big for a machine, it won't be processed by that machine. After we sort this out, we need the solutions written down and shown visually. Thanks![DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_TARDINESS_CONSTRAINTS]",#
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our objective is to optimize the scheduling process for Shiny Factory by minimizing makespan. The job specifications, categorized by quantity labels (very small, small, and large), are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities and the 7-Head Machine for managing small quantities. However, if a job's quantity exceeds the capacity of either machine, it will not be processed. Additionally, the stochastic nature of job release times adds complexity to the scheduling task. Once we address this challenge, thorough documentation and visual representation of the solutions will be essential for evaluation and further optimization.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
