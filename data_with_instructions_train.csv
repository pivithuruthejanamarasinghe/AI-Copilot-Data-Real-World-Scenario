prompt,completion
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []"
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)"
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_QUANTITY_CONSTRAINTS]",#
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_TARDINESS_CONSTRAINTS]",#
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_DATA_PREPARATION]","jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_MODEL]","def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_QUANTITY_CONSTRAINTS]",#
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_TARDINESS_CONSTRAINTS]",#
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_QUANTITY_CONSTRAINTS]",#
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machines—Little Fang Machine for very small jobs and 7-Head Machine for small ones—is predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []"
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)"
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_QUANTITY_CONSTRAINTS]",#
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_TARDINESS_CONSTRAINTS]",#
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]¶",#
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5"
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m"
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_QUANTITY_CONSTRAINTS]",#
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_QUANTITY_CONSTRAINTS]",#
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_QUANTITY_CONSTRAINTS]",#
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_TARDINESS_CONSTRAINTS","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machine—if its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_QUANTITY_CONSTRAINTS]",#
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_TARDINESS_CONSTRAINTS]",#
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5"
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m"
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]",#
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_TARDINESS_CONSTRAINTS]",#
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_QUANTITY_CONSTRAINTS]",#
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_TARDINESS_CONSTRAINTS]",#
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]",#
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show()"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []"
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon"
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)"
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_PREFERENCE_CONSTRAINTS]","# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_OVERLAPPING_CONSTRAINTS]","def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m"
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_QUANTITY_CONSTRAINTS]",#
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_WAITING_TIME_CONSTRAINTS]",#
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_TARDINESS_CONSTRAINTS]",#
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks![DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_TARDINESS_CONSTRAINTS]",#
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]",#
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labels—very small, small, and large—are outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5"
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]",#
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]",#
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]",#
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m"
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_QUANTITY_CONSTRAINTS]",#
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_TARDINESS_CONSTRAINTS]",#
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"ur objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS",#
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_MODEL]","# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]",#
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]",#
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_IMPORTS]","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_CONFIGURATIONS]","# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_7_HEAD_MACHINE]","# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_SPECIAL_ADJUSTMENT_FOR_LITTLE_FANG_MACHINE]","def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_UTILITY_FUNCTIONS]","# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_TARDINESS_UTILITY_FUNCTIONS]","# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_DATA_PREPARATION]","# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_MODEL]","# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_PREFERENCE_CONSTRAINTS]","# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_OVERLAPPING_CONSTRAINTS]","# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_QUANTITY_CONSTRAINTS]","# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_WAITING_TIME_CONSTRAINTS]","# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_TARDINESS_CONSTRAINTS]","def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_OBJECTIVE]","# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_VISUALIZATION]","# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() "
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machine—if its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.[DEFINE_SOLUTION]","# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
